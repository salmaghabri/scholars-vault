# DDD
Domain-Driven Design(DDD) is a collection of principles and patterns that help developers craft elegant object systems. Properly applied it can lead to software abstractions called domain models. These models encapsulate complex business logic, closing the gap between business reality and code. (...)
#### Les principes de base du DDD se résument comme suit :
— La conception centrée sur le domaine métier, en collaborant étroitement avec les experts.
— L’utilisation d’un langage commun entre développeurs et experts.
— Définir des frontières dans lesquelles un certain modèle est défini et est applicable (appelées Bounded Contexts). Chaque contexte borné encapsule un modèle spécifique, indépendant des autres, permettant de gérer la complexité en évitant les conflits ou les ambiguïtés entre différents modèles.
— Considérer les données comme un produit de l’entreprise, traitées avec la même attention :gestion de leur cycle de vie, leur qualité et leur adéquation avec les besoins utilisateurs.
### bounded context
L’un des désavantages des architectures microservices (mais aussi micro frontends) est l’obtention d’une application complexe due à l’utilisation d’un très grand nombre de microservices, souvent axés sur une entité unique plutôt que sur un contexte délimité (bounded context). 
>Bounded Context is a central pattern in Domain-Driven Design (DDD). It is the focus of DDD’s strategic design section which is all about dealing with large models and teams. DDD deals with large models by dividing them into different Bounded Contexts and being explicit about their interrelationships.

As you try to model a larger domain, it gets progressively harder to build a single unified model. Different groups of people will use subtly different vocabularies in different parts of a large organization. The precision of modeling rapidly runs into this, often leading to a lot of confusion. Typically this confusion focuses on the central concepts of the domain. Early in my career I worked with a electricity utility - here the word "meter" meant subtly different things to different parts of the organization : was it the connection between the grid and a location, the grid and a customer, the physical meter itself (which could be replaced if faulty). These subtle polysemes could be smoothed over in conversation but not in the precise world of computers. Time and time again I see this confusion recur with polysemes like "Customer" and "Product".
In those younger days we were advised to build a unified model of the entire business, but DDD recognizes that we’ve learned that "total unification of the domain model for a large system will not be feasible or cost-effective". So instead DDD divides up a large system into Bounded Contexts, each of which can have a unified model - essentially a way of structuring MultipleCanonicalModels.
### ubiquitous language 
ubiquitous language pour désigner la pratique consistant à construire un langage commun et rigoureux entre les développeurs et les utilisateurs. Ce langage doit être basé sur le modèle de domaine utilisé dans le logiciel - d’où la nécessité d’être rigoureux, car les logiciels ne supportent pas bien l’ambiguïté. l’utilisation du ubiquitous language dans des conversations avec des experts du domaine est une partie importante pour le tester, d’où la définition d’un modèle de domaine. Il insiste également sur le fait que le langage (et le modèle) doit évoluer au fur et à mesure que l’équipe
acquiert une meilleure compréhension du domaine.